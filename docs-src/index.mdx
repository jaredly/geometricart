import * as React from 'react';
import {
    insetLineLineTrace,
    insetLineLine,
    rawSource,
} from '../src/rendering/inset/lineLine.ts';
import { lineLine, lineToSlope } from '../src/rendering/intersect';
import { Fixtures } from './Fixtures';
import fixtures from './lineLine.json';
import { insetPrev, naiveInset } from '../src/rendering/ShowDebugInsetSegment';
import { RenderSegmentBasic } from '../src/editor/RenderSegment';
import { Arrow } from '../src/editor/ShowHitIntersection2';
import { angleTo, dist, push } from '../src/rendering/getMirrorTransforms';

# Playing with Polygons! (and more)

So the shapes we're dealing with consist of straight lines and arcs.
We could generalize this to deal with bezier curves too I think? idk.
Yeah as long as you give me an offset algorithm, it's fine. Looks like it's pretty computationally expensive, so beware I guess.

Anyway, the things we'll be talking about:

-   clipping one shape by another shape!

and

-   offsetting a shape! this will re-use some of the work from clipping a shape.

<Fixtures
    fixtures={fixtures}
    Input={({ input: [[p1, p2, p3], inset], onChange }) => {
        const [moving, setMoving] = React.useState(null);
        const ref = React.useRef(null);
        React.useEffect(() => {
            if (!moving || !ref.current) return;
            const fn = (evt) => {
                const box = ref.current.parentNode.getBoundingClientRect();
                let pos = {
                    x: evt.clientX - box.left,
                    y: evt.clientY - box.top,
                };
                if (moving.which === 2) {
                    const line = lineToSlope(p1, p3, true)
                    const cross = lineToSlope(pos, push(pos, angleTo(p1, p3) + Math.PI / 2, 10))
                    const p = lineLine(line, cross)
                    if (p && dist(pos, p) < 5) {
                        pos = p
                    }
                }
                {/* onChange([[p1, pos, p3], inset]); */}
                {/* setMoving({which: moving.which, pos}) */}
                onChange([[
                    moving.which === 1 ? pos: p1,
                    moving.which === 2 ? pos: p2,
                    moving.which === 3 ? pos: p3,
                ], 
                moving.which === 4 ? (pos.x - 150) : inset
                ]);
            };
            const up = (evt) => {
                const box = ref.current.parentNode.getBoundingClientRect();
                const pos = {
                    x: evt.clientX - box.left,
                    y: evt.clientY - box.top,
                };
                {/* onChange([[
                    moving.which === 1 ? pos: p1,
                    moving.which === 2 ? pos: p2,
                    moving.which === 3 ? pos: p3,
                ], inset]); */}
                setMoving(null);
            };
            document.addEventListener('mousemove', fn);
            document.addEventListener('mouseup', up);
            return () => {
                document.removeEventListener('mousemove', fn);
                document.removeEventListener('mouseup', up);
            };
        }, [moving ? moving.which : null]);
        /* p1 = moving?.which === 1 ? moving.pos : p1
        p2 = moving?.which === 2 ? moving.pos : p2
        p3 = moving?.which === 3 ? moving.pos : p3 */
        return (
            <>
                <g ref={(n) => (ref.current = n)}>
                    <polyline
                        points={`${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`}
                        stroke="red"
                        fill="none"
                        strokeWidth={2}
                    />
                    <circle
                        cx={p1.x}
                        cy={p1.y}
                        fill="red"
                        r={onChange ? 5 : 3}
                        style={{ cursor: 'pointer' }}
                        onMouseDown={onChange ? (evt) => {
                            evt.preventDefault();
                            const box = ref.current.parentNode.getBoundingClientRect();
                            const pos = {
                                x: evt.clientX - box.left,
                                y: evt.clientY - box.top,
                            };
                            setMoving({which: 1, pos});
                        } : null}
                    />
                    <circle
                        cx={p2.x}
                        cy={p2.y}
                        fill="red"
                        r={onChange ? 5 : 3}
                        style={{ cursor: 'pointer' }}
                        onMouseDown={onChange ? (evt) => {
                            evt.preventDefault();
                            const box = ref.current.parentNode.getBoundingClientRect();
                            const pos = {
                                x: evt.clientX - box.left,
                                y: evt.clientY - box.top,
                            };
                            setMoving({which: 2, pos});
                        } : null}
                    />
                    <Arrow
                        point={p3}
                        theta={angleTo(p2, p3)}
                        size={onChange ? 20 : 10}
                        color="red"
                        inner={{
                            style: onChange? {cursor: 'pointer'} : null,
                        onMouseDown: onChange ? (evt) => {
                            evt.preventDefault();
                            const box = ref.current.parentNode.getBoundingClientRect();
                            const pos = {
                                x: evt.clientX - box.left,
                                y: evt.clientY - box.top,
                            };
                            setMoving({which: 3, pos});
                        } : null

                        }}
                    />
                    {onChange ? <>
                        <circle
                            cx={150} cy={280}
                            r={3}
                            stroke="black"
                            strokeWidth="2"
                            fill="none"
                        />
                        <text
                            x={150} y={295}
                            textAnchor="middle"
                            fontFamily="sans-serif"
                            fontSize={10}
                            fill="black"
                        >
                            {inset.toFixed(0)}
                        </text>
                        <line
                            x1={20} y1={280}
                            x2={280} y2={280}
                            stroke="black"
                            strokeDasharray="1 1"
                            strokeWidth="1"
                        />
                        <circle
                        cx={150 + (inset )}
                        cy={280}
                        r={5}
                        fill="black"
                        style={{ cursor: 'pointer' }}
                        onMouseDown={onChange ? (evt) => {
                            evt.preventDefault();
                            const box = ref.current.parentNode.getBoundingClientRect();
                            const pos = {
                                x: evt.clientX - box.left,
                                y: evt.clientY - box.top,
                            };
                            setMoving({which: 4, pos});
                        } : null}
                        />
                    </> : null}
                </g>
            </>
        );
    }}
    Output={({ output: segments, input: [[p1, p2, p3], inset] }) => {
        const naive = naiveInset(
            { prev: p2, segment: { type: 'Line', to: p3 } },
            inset,
        );
        return (
            <>
            <g style={{pointerEvents: 'none'}}>
                {
                    <RenderSegmentBasic
                        prev={segments[segments.length - 1].to}
                        segment={naive.segment}
                        zoom={1}
                        inner={{
                            stroke: 'green',
                            strokeWidth: 1,
                            strokeDasharray: '5 5',
                        }}
                    />
                }
                {segments.map((seg, i) => (
                    <RenderSegmentBasic
                        key={i}
                        prev={
                            i === 0
                                ? insetPrev(p1, { type: 'Line', to: p2 }, inset)
                                : segments[i - 1].to
                        }
                        segment={seg}
                        zoom={1}
                        inner={{ stroke: 'green', strokeWidth: 3 }}
                    />
                ))}
                </g>
            </>
        );
    }}
    source={rawSource}
    run={([[p1,p2,p3],inset]) => {
        return insetLineLine(
            p1,
            { type: 'Line', to: p2 },
            { type: 'Line', to: p3 },
            inset,
        );
    }}
    info={insetLineLineTrace.traceInfo}
    trace={([[p1, p2, p3], inset], trace) => {
        return insetLineLineTrace(
            p1,
            { type: 'Line', to: p2 },
            { type: 'Line', to: p3 },
            inset,
            trace,
        );
    }}

/>

Ok so how was that?

<div style={{ height: 200 }} />
