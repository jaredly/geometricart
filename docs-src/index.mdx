import {
    insetLineLineTrace,
    rawSource,
} from '../src/rendering/inset/lineLine.ts';
import { Fixtures } from './Fixtures';
import fixtures from './lineLine.json';
import { insetPrev, naiveInset } from '../src/rendering/ShowDebugInsetSegment';
import { RenderSegmentBasic } from '../src/editor/RenderSegment';
import { Arrow } from '../src/editor/ShowHitIntersection2';
import { angleTo, dist, push } from '../src/rendering/getMirrorTransforms';

# Playing with Polygons! (and more)

So the shapes we're dealing with consist of straight lines and arcs.
We could generalize this to deal with bezier curves too I think? idk.
Yeah as long as you give me an offset algorithm, it's fine. Looks like it's pretty computationally expensive, so beware I guess.

Anyway, the things we'll be talking about:

-   clipping one shape by another shape!

and

-   offsetting a shape! this will re-use some of the work from clipping a shape.

<Fixtures
    fixtures={fixtures}
    Input={({ input: [[p1, p2, p3], inset] }) => (
        <>
            <polyline
                points={`${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`}
                stroke="red"
                fill="none"
                strokeWidth={2}
            />
            <circle cx={p2.x} cy={p2.y} fill="red" r={3} />
            <Arrow point={p3} theta={angleTo(p2, p3)} size={10} color="red" />
            {/* <text x={0} y={20}>
                inset: {inset}
            </text> */}
        </>
    )}
    Output={({ output: segments, input: [[p1, p2, p3], inset] }) => {
        const naive = naiveInset(
            { prev: p2, segment: { type: 'Line', to: p3 } },
            inset,
        );
        return (
            <>
                {
                    <RenderSegmentBasic
                        prev={segments[segments.length - 1].to}
                        segment={naive.segment}
                        zoom={1}
                        inner={{
                            stroke: 'green',
                            strokeWidth: 1,
                            strokeDasharray: '5 5',
                        }}
                    />
                }
                {segments.map((seg, i) => (
                    <RenderSegmentBasic
                        key={i}
                        prev={
                            i === 0
                                ? insetPrev(p1, { type: 'Line', to: p2 }, inset)
                                : segments[i - 1].to
                        }
                        segment={seg}
                        zoom={1}
                        inner={{ stroke: 'green', strokeWidth: 3 }}
                    />
                ))}
            </>
        );
    }}
    source={rawSource}
    trace={([[p1, p2, p3], inset], trace) => {
        insetLineLineTrace(
            p1,
            { type: 'Line', to: p2 },
            { type: 'Line', to: p3 },
            inset,
            trace,
        );
    }}
/>

Ok so how was that?

<div style={{ height: 200 }} />
